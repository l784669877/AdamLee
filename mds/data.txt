数据类型 BOOL
- 长度（位）: 1
- 格式: 布尔型
- 取值范围: FALSE 或 TRUE

数据类型 BYTE
- 长度（位）: 8
- 格式: 整数
- 取值范围: 有符号整数 -128 到 +127, 无符号整数 0 到 255
BYTE 数据类型无法比较大小。该数据类型可处理的十进制数，与 SINT 和 USINT 数据类型处
理的数据相同

WORD:
- 长度（位）：16
- 格式：整数（十进制系统）、二进制数、八进制数、十六进制数
- 取值范围：有符号整数：-32_768 到 +32_767，无符号整数：0 到 65_535
- 输入值示例：61_680、WORD#61_680、W#61_680、MW10、DB1.DBW2、Tag_Name

DWORD:
- 长度（位）：32
- 格式：整数（十进制系统）、二进制数、八进制数、十六进制数
- 取值范围：有符号整数：-2_147_483_647 到 +2_147_483_647，无符号整数：0 到 4_294_967_295
- 输入值示例：+15_793_935、DWORD#+15_793_935、DW#+15_793_935、MD10、DB1.DBD8、Tag_Name

LWORD:
- 长度（位）：64
- 格式：整数（十进制系统）、二进制数、八进制数、十六进制数
- 取值范围：有符号整数：-9_223_372_036_854_775_808 到 +9_223_372_036_854_775_807，无符号整数：0 到 18_446_744_073_709_551_615
- 输入值示例：+26_123_590_360_715、LWORD#+26_123_590_360_715、LW#+26_123_590_360_715

注意：WORD、DWORD 和 LWORD 数据类型无法比较大小。它们只能处理可由相应整数数据类型处理的相同的十进制数据。SCL 和 GRAPH 中无法使用“十进制序列”格式。

LWORD 数据类型的属性：
- 长度（位）：64
- 格式：整数（十进制系统），二进制数，八进制数，十六进制数，十进制序列
- 取值范围：有符号整数 -9_223_372_036_854_775_808 到 +9_223_372_036_854_775_807，无符号整数 0 到 18_446_744_073_709_551_615
- 输入值示例：+26_123_590_360_715, LWORD#+26_123_590_360_715, LW#+26_123_590_360_715

SINT 数据类型的属性：
- 长度（位）：8
- 格式：有符号整数（十进制系统），二进制数（仅正数），八进制数（仅正数），十六进制数（仅正数）
- 取值范围：-128 到 +127
- 输入值示例：+44, SINT#+44, SINT#2#0010_1100

USINT 数据类型的属性：
- 长度（位）：8
- 格式：无符号整数（十进制系统），二进制数，八进制数，十六进制数
- 取值范围：0 到 255
- 输入值示例：78, USINT#78, USINT#2#0100_1110

INT 数据类型的属性：
- 长度（位）：16
- 格式：有符号整数（十进制系统），二进制数（仅正数），八进制数（仅正数），十六进制数（仅正数）
- 取值范围：-32_768 到 +32_767
- 输入值示例：+3_785, INT#+3_785, INT#2#0000_1110_1001

INT（16位整数）:
- 长度为16位
- 由符号和数值两部分组成
- 位0到14表示数值，位15表示符号
- 符号可以是0（正）或1（负）
- 取值范围为-32_768到+32_767
- 在存储器中占用2 BYTE

UINT（16位整数）:
- 长度为16位
- 包含无符号数值
- 取值范围为0到65_535
- 在存储器中占用2 BYTE

DINT（32位整数）:
- 长度为32位
- 由符号和数值两部分组成
- 位0到30表示数值，位31表示符号
- 符号可以是0（正）或1（负）
- 取值范围为-2_147_483_648到+2_147_483_647
- 在存储器中占用4 BYTE

UDINT（32位整数）:
- 长度为32位
- 包含无符号数值
- 取值范围为0到4_294_967_295
- 在存储器中占用4 BYTE

UDINT 数据类型的操作数长度为 32 位，包括无符号数值。UDINT 的操作数在存储器中占用 4 BYTE。

LINT 数据类型的操作数长度为 64 位，并由两部分组成：一部分是符号，另一部分是数值。位 0 到 62 的信号状态表示数值。位 63 的信号状态表示符号。符号可以是 “0”（正信号状态），或 “1”（负信号状态）。LINT 的操作数在存储器中占用 8 BYTE。

ULINT 数据类型的操作数长度为 64 位，包括无符号数值。ULINT 的操作数在存储器中占用 8 BYTE。

数据类型 REAL 的操作数长度为 32 位，用于表示浮点数。数据类型 REAL 的操作数由以下三部分组成：
- 符号：该符号由第 31 位的信号状态确定。第 31 位的值可以是 “0”（正数）或 “1”（负数）。
- 以 2 为底的 8 位指数：该指数按常数增加（基值 +127），因此其范围为 0 ～ 255。
- 23 位尾数：仅显示尾数的小数部分。尾数为标准化的浮点数，其整数部分始终为 1，且不会保存。
处理 REAL 数据类型时会精确到 6 位数。

数据类型 LREAL 的操作数长度为 64 位，用于表示浮点数。数据类型 LREAL 的操作数由以下三部分组成：
- 符号：该符号由第 63 位的信号状态确定。第 63 位的值可以是 “0”（正数）或 “1”（负数）。
- 以 2 为底的 11 位指数：该指数按常数增加（基值 +1023），因此其范围为 0 ～ 2047。
- 52 位尾数：仅显示尾数的小数部分。尾数为标准化的浮点数，其整数部分始终为 1，且不会保存。
处理 LREAL 数据类型时会精确到 15 位数。

无效浮点数包括：
- 无穷数：+Inf/-Inf（无穷）
- 无效数：NaN（非数字）

浮点数将按照 IEEE754 标准进行保存。转换结果或带有非规范化、无限或 NaN（非数字）浮点数的算术函数的结果取决于 CPU。

S7-1200 V1、V2 和 V3 系列的 CPU 比较运算“等于”使用无效浮点数的位模式。如果比较具有相同位模式的 2 个“NaN 数值”，则“等于”运算的输出将返回结果 TRUE。

S7-1200 V4 和 S7-1500 系列的 CPU 如果比较两个无效数值 (NaN)，则结果将始终为 FALSE，而与无效数值的位模式及比较关系 (>, >=, ...) 无关。

比较非标准浮点数时，S7-300/400 系列 CPU 的输出信号状态将置位为 “0”，而 S7-1200/1500 系列 CPU 的输出信号状态则将置位为 “1”。

如果算术函数的输入变量表示无效浮点数，那么无效浮点数也将作为结果输出。可以通过查询使能输入 ENO 是否为 FALSE 或对状态位 OV 进行判断来识别由无效浮点数引起的可能错误。

浮点数将按照IEEE754标准进行保存。转换结果或带有非规范化、无限或NaN（非数字）浮点数的算术函数的结果取决于CPU。

浮点数值可超出有效的数字值范围内。

S7-1200 V1、V2和V3系列的CPU：比较运算“等于”使用无效浮点数的位模式。如果比较具有相同位模式的2个“NaN数值”，则“等于”运算的输出将返回结果TRUE。

S7-1200 V4和S7-1500系列的CPU：如果比较两个无效数值(NaN)，则结果将始终为FALSE，而与无效数值的位模式及比较关系(>, >, ...)无关。

比较非标准浮点数：S7-300/400系列CPU的输出信号状态将置位为“0”，而S7-1200/1500系列CPU的输出信号状态则将置位为“1”。

S5TIME数据类型将持续时间存储为BCD格式。持续时间的生成基于0到999范围内的时间值和时间基线。时间基线指示定时器时间值按步长1减少直至为“0”的时间间隔。时间的分辨率可以通过时间基线来控制。

TIME数据类型为有符号的持续时间，内容以毫秒表示。表示信息包括天(d)、小时(h)、分钟(m)、秒(s)和毫秒(ms)。

LTIME数据类型为有符号的持续时间，内容以纳秒表示。表示信息包括天(d)、小时(h)、分钟(m)、秒(s)、毫秒(ms)、微秒(us)和纳秒(ns)。

DATE数据类型将日期作为无符号整数保存。表示法中包括年、月和日。DATE的操作数为十六进制形式，对应于自01-01-1990以来的日期值(16#0000)。

DATE 数据类型的操作数为十六进制形式，对应于自 01-01-1990 以来的日期值 (16#0000)。
- 长度（字节）：2
- 格式：IEC 日期（年-月-日）
- 取值范围：D#1990-01-01 到 D#2169-06-06
- 输入值示例：D#2009-12-31 ，DATE#2009-12-31

TOD (TIME_OF_DAY) 数据类型占用一个双字，存储从当天 0:00 h 开始的毫秒数，为无符号整数。
- 长度（字节）：4
- 格式：时间（小时:分钟:秒.毫秒）
- 取值范围：TOD#00:00:00.000 到 TOD#23:59:59.999
- 输入值示例：TOD#10:20:30.400 ，TIME_OF_DAY#10:20:30.400

LTOD (LTIME_OF_DAY) 数据类型占用 2 个双字，存储从当天 0:00 h 开始的纳秒数，为无符号整数。
- 长度（字节）：8
- 格式：时间（小时:分钟:秒.纳秒）
- 取值范围：LTOD#00:00:00.00000000 到 LTOD#23:59:59.99999999
- 输入值示例：LTOD#10:20:30.400_365_215，LTIME_OF_DAY#10:20:30.400_365_215

DT (DATE_AND_TIME) 数据类型存储日期和时间信息，格式为 BCD。
- 长度（字节）：8
- 格式：日期和时间（年-月-日-小时：分钟：秒：毫秒）
- 值范围：最小值：DT#1990-01-01-00:00:00.000，最大值：DT#2089-12-31-23:59:59.999
- 输入值示例：DT#2008-10-25-08:12:34.567，DATE_AND_TIME#2008-10-25-08:12:34.567

LDT (DATE_AND_LTIME) 数据类型可存储自 1970 年 1 月 1 日 0:0 以来的日期和时间信息（单位为纳秒）。
- 长度（字节）：8
- 格式：日期和时间（年-月-日-小时:分钟:秒:纳秒）
- 取值范围：最小值：LDT#1970-01-01-00:00:00.000000000，最大值：LDT#2262-04-11-23:47:16.854775807
- 输入值示例：LDT#2008-10-25-08:12:34.567

DTL 数据类型的操作数长度为 12 个字节，以预定义结构存储日期和时间信息。
- 长度（字节）：12
- 格式：预定义结构
- 取值范围：未提供
- 输入值示例：未提供

LDT (DATE_AND_LTIME)
- 长度：8字节
- 格式：日期和时间（年-月-日-小时:分钟:秒:纳秒）
- 取值范围：最小值 LDT#1970-01-01-00:00:00.000000000，最大值 LDT#2262-04-11-23:47:16.854775807
- 输入值示例：LDT#2008-10-25-08:12:34.567

DTL
- 长度：12字节
- 格式：日期和时间（年-月-日-小时:分钟:秒:纳秒）
- 取值范围：最小值 DTL#1970-01-01-00:00:00.0，最大值 DTL#2262-04-11-23:47:16.854775807
- 输入值示例：DTL#2008-12-16-20:30:20.250
- 结构组成：
  - 字节0：年（UINT，1970到2262）
  - 字节1-2：月（USINT，1到12）
  - 字节3：日（USINT，1到31）
  - 字节4：星期（USINT，1到7）
  - 字节5：小时（USINT，0到23）
  - 字节6：分钟（USINT，0到59）
  - 字节7：秒（USINT，0到59）
  - 字节8-11：纳秒（UDINT，0到999999999）

CHAR
- 长度：8位
- 格式：ASCII字符
- 值范围：ASCII字符集
- 输入值示例：'A'，CHAR#'A'

WCHAR
- 长度：16位
- 格式：Unicode
- 值范围：$0000 - $D7FF
- 输入值示例：WCHAR#'a'

STRING
- 长度：n + 2字节（包括2个字节的字符串长度信息）
- 格式：ASCII字符串，包括特殊字符
- 值范围：0到254个字符
- 输入值示例：'Name'，STRING#'NAME'，STRING#'Na...'（实际长度超出屏幕空间），STRING#''（空字符串）
- 特殊字符表示法示例：
  - $L 或 $l：换行
  - $N：断行
  - $P 或 $p：分页
  - $R 或 $r：回车 (CR)
  - $T 或 $t：切换
  - $$：美元符号
  - $'：单引号

STRING 变量的属性：
- 长度（字节）：n + 2
- 格式：ASCII 字符串，包括特殊字符
- 值范围：0 到 254 个字符
- 输入值示例：'Name', STRING#'NAME', STRING#'Na...', STRING#'' (空字符串)

特殊字符表示法示例：
- $L 或 $l：0A 换行，例如 '$LText', '$0AText'
- $N：0A 和 0D 断行，例如 '$NText', '$0A$0DText'
- $P 或 $p：0C 分页，例如 '$PText', '$0CText'
- $R 或 $r：0D 回车 (CR)，例如 '$RText', '$0DText'
- $T 或 $t：09 切换，例如 '$TText', '$09Text'
- $$：24 美元符号，例如 '100$$', '100$24'
- $'：27 单引号，例如 '$'Text$'', '$27Text$27'

WSTRING 变量的属性：
- 长度（字）：n + 2
- 格式：Unicode 字符串
- 值范围：0 到 16382 个字符
- 输入值示例：WSTRING#'Hello World', WSTRING#'Hello Wo...', WSTRING#'' (空字符串)

WSTRING 特殊字符表示法示例：
- $L 或 $l：000A 换行，例如 '$LText', '$000AText'
- $N：000A 和 000D 断行，例如 '$NText', '$000A$000DText'
- $P 或 $p：000C 分页，例如 '$PText', '$000CText'
- $R 或 $r：000D 回车 (CR)，例如 '$RText', '$000DText'
- $T 或 $t：0009 切换，例如 '$TText', '$0009Text'
- $$：0024 美元符号，例如 '100$$', '100$0024'
- $'：0027 单引号，例如 '$'Text$'', '$0027Text$0027'

WSTRING 变量的属性：
- 长度（字）：n + 2
- 格式：Unicode 字符串
- 值范围：0 到 16382个字符
- 输入值示例：WSTRING#'Hello World'

特殊字符表示法示例：
- $L 或 $l：000A 换行
- $N：000A 和 000D 断行
- $P 或 $p：000C 分页
- $R 或 $r：000D 回车 (CR)
- $T 或 $t：0009 切换
- $$：0024 美元符号
- $'：0027 单引号

WSTRING 变量的转换：
- WSTRING 不支持后台转换，需要显式转换为 STRING 数据类型。

监控表中的应用：
- 仅显示前 254 个字符，超过时显示省略号 (…)

在 SCL 中使用：
- 生成超长 WSTRING 时，结果可能会被系统截断，需检查 ENO 是否为 FALSE。

字符串的最大长度：
- 可在关键字 WSTRING 后使用方括号指定字符串的最大长度。

传送 WSTRING 数据类型的参数：
- WSTRING 操作数可作为参数传递，长度为具有“优化”访问权的块的最大长度。

寻址 STRING 或 WSTRING 中的具体字符：
- 使用语法 StringName[i] 访问具体字符，i 从 1 开始。

W(STRING) 访问的故障查找与排除：
- 超出 STRING 长度时会导致访问错误，ENO 会被设置为 FALSE。

传递 STRING 或 WSTRING 数据类型的变量：
- 不同 CPU 系列中 (W)STRING 的传递规则不同，S7-1200/1500 中声明的形参和实参长度可以不同。

可以将 STRING 或 WSTRING 数据类型的变量作为参数进行传递。以下是指定的传递规则：

CPU 系列 | 数据类型 | 块调用中的传递规则
---|---|---
S7-300/400 | STRING | 声明的形参和实参长度必须相同。
S7-1200/1500 | STRING, WSTRING | 声明的形参和实参长度可以不同。如果目标参数的声明长度小于接收的 (W)STRING 参数长度，则截断 (W)STRING 参数并将使能输出 ENO 设置为 FALSE。

PLC 数据类型 (UDT) 是一种复杂的用户自定义数据类型，用于声明一个变量。这种数据类型是一个由多个不同数据类型元素组成的数据结构。其中，各元素可源自其他 PLC 数据类型、ARRAY，也可直接使用关键字 STRUCT 声明为一个结构。PLC 数据类型 (UDT) 的嵌套深度限制为 8 级。

声明为 PLC 数据类型 (UDT) 的变量也可作为实参进行传递。如果形参在变量声明中声明为 PLC 数据类型 (UDT)，则待传递变量的 PLC 数据类型 (UDT) 必须与实参的相同。在块调用时，声明为 PLC 数据类型 (UDT) 的变量元素也可作为实参进行传递，但前提是该变量元素的数据类型与形参数据类型相匹配。

声明为 PLC 数据类型 (UDT) 的变量也可作为实参进行传递。如果形参在变量声明中声明为 PLC 数据类型 (UDT)，则待传递变量的 PLC 数据类型 (UDT) 必须与实参的相同。

PLC 数据类型可用作模板，创建各种程序元素。例如，可从 PLC 数据类型生成 PLC 变量或数据块。因此，无法直接访问 PLC 数据类型。但可以访问基于某个 PLC 数据类型创建的程序元素。语法结构为：<程序元素名称>.<元素名称>

命名值数据类型的声明语法：
NAMESPACE <name> 
{ PUBLISHED := 'TRUE|FALSE' } 
    TYPE
        <namedValueType> : <BaseType> 
        (
                <NAME_1> := <Value_1>,
                <NAME_2> := <Value_2>,
                <NAME_3> := <Value_3>
        ) := <Default>;
    END_TYPE 
END_NAMESPACE

命名值数据类型的使用：
- 可在块接口中基于命名值数据类型声明参数。
- 可在全局数据块中基于命名值数据类型声明元素。
- 可在 PLC 数据类型 (UDT) 中基于命名值数据类型声明元素。

命名值的唯一寻址形式：<namedValueType>#<NAMED_VALUE>

语法元素 说明
//comment可选
行注释直到行尾。
(* comment section *)
/* comment section */
可选
注释部分可跨多个行。  

使用命名值数据类型
命名值数据类型可用作模板，用于创建各种程序元素。可按以下方式进行更换：
•可在块接口中基于命名值数据类型声明参数。
•可在全局数据块中基于命名值数据类型声明元素。
•可在 PLC 数据类型 (UDT) 中基于命名值数据类型声明元素。

不自动更新参考位置
由于命名值数据类型采用文档化编程，因此参考位置不自动更新。例如，如果对命名值数据类型进行重命名，则不会自动修改 PLC 程序中的参考位置。而是会在编译期间报告语法错误。此时需要手动更新参考位置。

唯一寻址命名值
可在运算中使用命名值，方法与基本数据类型的其它常量相同。其也可用于声明 ARRAY 边界或 STRING 长度。
为获得唯一标识，请采用以下形式指定命名值数据类型，后跟命名值的名称：
<namedValueType>#<NAMED_VALUE> 

命名值数据类型 "nvtMoveAbsoluteDirection"
命名值数据类型 "nvtPositionerStatus"
工艺对象 "TO_PositioningAxis" 的调用
•轴具有输入参数 "Direction"，其控制轴的运动方向。调用轴时，参数的实际值由 "nvtMoveAbsoluteDirection" 传送。
•轴具有不同的输出参数，这些参数将轴的状态信息返回给调用块。状态值通过 IF 指令传送到 "nvtPositionerStatus"。 

命名值数据类型 "nvtOperationStates"
一个通过使用 CASE 语句来更改 "nvtOperationStates" 值的块。通过这种方式，可以为 "nvtOperationStates" 的所有参考位置集中设置过程的当前状态。

命名值数据类型用于在整个程序中为状态分配唯一名称，以便于在整个程序中引用状态。

STRUCT数据类型是一种元素数量固定但数据类型不同的数据结构。结构也支持嵌套，并可以包含STRUCT或ARRAY数据类型的元素。结构可用于根据过程控制系统分组数据以及作为一个数据单元来传送参数。

匿名结构的缺点包括：
- 维护成本增加：如果对一个匿名结构进行了多次复制，则在更改过程中该匿名结构也必须进行相应的多次更改。
- 匿名结构与PLC数据类型(UDT)的相同结构不兼容。
- 由于系统会检查所有结构元素的类型是否匹配，因而会导致性能下降。
- 存储空间要求增加：每个匿名结构都是一个单独的对象，其描述信息将加载到AS中。

STRUCT变量的结构：
- STRUCT变量通常从一个非优化块的一个字限值处开始（即，偶数地址的字节处）。
- 各元素随后按照存储器中声明的顺序进行排列。
- STRUCT变量占用的存储空间直至下一个字限值处。
- 数据类型为BOOL的元素从最低有效位处开始。
- 数据类型为BYTE和CHAR的元素将从下一个字节处开始。
- 不同数据类型的元素将从一个字限值处开始。
- 在优化块中，结构存储时将根据块的大小进行排序，存储中的顺序与编辑器中的显示顺序不对应。
- 在嵌套结构中，该结构可作为另一个结构的元素，嵌套深度最多可包含8个结构。
- 所有元素均可单独寻址，各元素的名称之间使用句点进行分隔。

如果结构非常复杂，则对结构进行分析可能会导致相应指令的执行时间意外增加。除在运算中指定结构化变量的复杂程度之外，程序中声明的匿名结构总数也会影响指令的运行时间。大量不同的匿名结构定义也会增加指令的运行时间。

STRUCT变量的结构：
- STRUCT变量通常从一个非优化块的一个字限值处开始（即，偶数地址的字节处）。各元素随后按照存储器中声明的顺序进行排列。STRUCT变量占用的存储空间直至下一个字限值处。
- 数据类型为BOOL的元素从最低有效位处开始。数据类型为BYTE和CHAR的元素将从下一个字节处开始。不同数据类型的元素将从一个字限值处开始。
- 在优化块中，结构存储时根据块的大小进行排序。存储中的顺序与编辑器中的显示顺序不对应。

寻址STRUCT元素：
- 通过"<块名称>.结构.元素"的语法，可访问结构中的单个元素。
- 示例："Global_DB".Motor.Valves寻址全局数据块"Global_DB"中结构"Motor"内的"Valves"元素。

传递STRUCT数据类型的变量：
- 如果元素与形参的数据类型相对应，则也可将STRUCT变量的各元素作为实参进行传递。也可将整个结构作为参数进行传递。
- 如果块中的输入参数为STRUCT数据类型，则必须传递结构相同的STRUCT作为实参。即，所有结构元素的名称和数据类型都必须相同。

ARRAY数据类型：
- ARRAY数据类型的变量表示一个由多个数目固定且数据类型相同元素组成的数据结构。这些元素可使用除ARRAY之外的所有数据类型。
- ARRAY限值可使用整数或全局/局部常量定义的固定值，也可定义为块的形参，或使用ARRAY[*]进行定义。下限值必须小于或等于上限值。一个ARRAY最多可包含六个维度，各维度的限值使用逗号进行分隔。

ARRAY属性：
- 标准块：ARRAY[下限..上限] of <数据类型>
- 多重实例优化块：[-2147483648..2147483647] of <数据类型>
- 全局数据块/变量表：使用整数作为ARRAY固定限值，使用全局常量作为ARRAY固定限值
- 块接口：使用整数作为ARRAY固定限值，使用全局常量作为ARRAY固定限值，使用局部常量作为ARRAY固定限值，使用可变ARRAY限值ARRAY[*]

对于块属性为“优化块访问”的块，BOOL数据类型的一个元素需要占用1个字节的存储空间。ARRAY of <数据类型>时，也同样如此。例如，在优化程序块中的ARRAY[0..1] of BOOL需要占用2个字节。

块属性 格式 ARRAY 限值 数据类型
标准块 ARRAY[下限 ..上限 ] of <数据类型> [-32768..32767] of <数据类型> 除 ARRAY 之外的所有数据类型。
多重实例 优化块 ARRAY[-2147483648..2147483647] of <数据类型>
根据所声明的 ARRAY，可使用不同方式定义 ARRAY 的限值。
ARRAY 限值 全局数据块 / 变量表 块接口
使用整数作为 ARRAY 固定限值 √ √
使用全局常量作为 ARRAY 固定限值 √ √
使用局部常量作为 ARRAY 固定限值 - √
使用可变 ARRAY 限值 ARRAY[*] - √
ARRAY of 多重实例 - √
适用于 S7-1500 系列 CPU
对于块属性为“优化块访问”的块， BOOL 数据类型的一个元素需要占用 1 个字节的存储空间。 ARRAY of <数据类型> 时，也同样如此。例如，在优化程序块中的 ARRAY [0..1] of BOOL 需要占用 2 个字节。

使用整数作为 ARRAY 固定限值
可使用整数作为 ARRAY 的固定限值：
• 一维 ARRAY 的示例
• 三维 ARRAY 的示例

使用常量作为 ARRAY 固定限值
可使用局部或全局常量作为 ARRAY 的固定限值：
• 一维 ARRAY 的 ARRAY 固定限值，由两个全局用户常量组成
• 一维 ARRAY 的 ARRAY 固定限值，由两个全局用户常量组成
• 二维 ARRAY 的 ARRAY 固定限值，由全局常量和局部常量组成

使用整数和全局/局部常量作为 ARRAY 固定限值
以上三种定义方式可组合使用，在一个 ARRAY 中可混合使用整数和全局/局部常量作为 ARRAY 限值。

使用可变 ARRAY 限值 ARRAY[*] （仅适用于优化访问块中）
在块编程中使用 ARRAY[*]，可灵活应对不同长度的 ARRAY。为此，可将函数或函数块的参数声明为限值可变的 ARRAY。ARRAY[*] 支持所有编程语言。
在运行过程中，可通过 “LOWER_BOUND” 和“UPPER_BOUND” 指令读取可变限值 ARRAY 的下限值和上限值。

ARRAY[*] 的可用性
对于固件版本 V4.2 及更高版本的 S7-1200 系列 CPU 以及固件版本 V2.0 及更高版本的 S7-1500 系列 CPU，ARRAY[*] 可用于优化块中。在函数 (FC) 中，可在所有声明子区域中使用 ARRAY[*]。在函数块 (FB) 中，ARRAY[*] 只能声明为 “InOut”区域中的 in-out 参数。

使用多重实例（仅适用于优化访问块中）
例如，可将多重实例创建为 ARRAY，从而在程序循环过程中使用可变下标对各个多重实例进行寻址。

一维 ARRAY 的可变 ARRAY 限值：

ARRAY[*] 应用的更多信息，请参见：
- "传递 ARRAY / ARRAY[*] 数据类型的变量 (页 331)"
- "块接口中的 声明 ARRAY 数据类型的变量 (页 9617)"

多维数组中 ARRAY 变量的结构：
- 各元素从第一个维度开始，逐行（逐维）存储。
- 在位和字节元素中，新维度通常从下一个字节处开始。
- 在其他数据类型的元素中，新维度通常从在非优化块中的下一个字（下一个偶数字节）开始。
- 在优化块中，每个维度所需的空间大小与第一维度的相同。

寻址 ARRAY 元素：
- ARRAY 元素是使用固定可变下标进行寻址。
- 元素的下标在方括号中指定，包含 ARRAY 各维度的一个整数值（固定下标）或一个变量（可变下标）。

ARRAY 访问的错误处理：
- S7-300/400: CPU 切换为 "STOP" 模式，可编写程序执行错误 OB (OB 85) 防止这一状况。
- S7-1200: CPU 生成诊断缓冲条目，并保持 "RUN" 模式。
- S7-1500: CPU 切换为 "STOP" 模式，可编写程序错误 OB (OB 121) 防止这一状况。

传递 ARRAY 数据类型的变量：
- ARRAY 中各元素的数据类型与形参的数据类型相同时，可作为实参进行传递。
- ARRAY 数据类型的变量可作为参数进行传递，结构必须与形参的相同（数据类型、维数和域元素的个数）。

ARRAY 访问的错误处理
- S7-300/400: CPU 切换为 “STOP”模式。可编写程序执行错误 OB (OB 85) 防止这一状况。在 SCL 中，可以启用块属性中的“检查 ARRAY 限值”(Check ARRAY limits) 属性。
- S7-1200: CPU 生成诊断缓冲条目，并保持为 “RUN”模式。
- S7-1500: CPU 切换为 “STOP”模式。可编写程序错误 OB (OB 121) 防止这一状况。可通过指令 “GET_ERROR：获取本地错误信息”或 “GET_ERROR_ID：获取本地错误 ID”编写本地错误处理方式。

通过 ENO 监视 ARRAY 访问错误
- 在指令执行过程中超出 ARRAY 的限值，则不会将使能输出 ENO 的信号状态设置为 FALSE，除非是 S7-300/400 系列 CPU 中属性设置为 “检查 ARRAY 限值”的 SCL 块。

传递 ARRAY/ARRAY[*] 数据类型的变量
- ARRAY 数据类型的变量可作为参数进行传递。如果块中的输入参数为 ARRAY 数据类型，则传递 ARRAY 时的结构必须与实参的相同。
- ARRAY[*] 可用于声明函数或函数块参数中限值可变的 ARRAY。创建块时，可定义 ARRAY 的限值。之后，在运行过程中调用该数组后将会传递该限值。

传递灵活限值 ARRAY 时的应用规则
- 如果维数与数据类型都匹配，则可将 ARRAY[*] 指定给 ARRAY[*]。
- 可将已知限值的 ARRAY 指定给 ARRAY[*]。
- ARRAY[*] 可指定给 VARIANT。
- ARRAY[*] 不能指定给固定限值的 ARRAY。

ARRAY[*] 类型的块参数由一个实参提供。
ARRAY[*] 不能指定给固定限值的 ARRAY。
ARRAY[*] 类型的块参数由一个实参提供。
ARRAY 数据类型的变量最多支持 6 维。数组维数将写入声明中的方括号内，并使用逗号进行分隔。在多维数组中，各元素从第一维度开始存储。

访问元素通过下标，可使用常量或变量作为下标。
LOWER_BOUND 和 UPPER_BOUND 指令用于读取 ARRAY 的边界。

函数 “ScalarProduct_FC” 作为创建计算标积时计算操作步骤的模板。在函数中，首先查询两个矢量的 ARRAY 上/下边界，然后确定两个矢量 ARRAY 的关联数。如果 ARRAY 的上/下边界不同，则函数返回值 “-1”并退出。如果 ARRAY 的上/下边界相同，则进行标积计算。

引用是一种变量，不含任何值却指向其它变量的存储位置。
对引用进行声明时，需指定被引用变量的数据类型。引用为类型安全。
在程序中使用引用，要求 S7-1500 系列 CPU 的固件版本为 V2.5 或更高版本。

引用的声明示例：
```
#myRefArray : REF_TO Array[0..100] of myType;
#myRefType : REF_TO myType;
#myRefInt : REF_TO INT;
```

引用的赋值示例：
```
#myRefInt := REF(#myInt);
#myRefType := REF("myDB".myType);
#myRefArray := REF(#myArray);
```

引用的解引用和访问元素示例：
```
#myInt := #myRefInt^;
#myInt := #myRefType^.elementOfInt;
#myInt := #myRefArray^[#index].elementOfInt;
```

检查引用是否为 NULL 示例：
```
IF #myRefInt = NULL THEN...;
```

引用与 VARIANT 的不同之处：
- VARIANT 数据类型的变量在程序创建时无需定义所指向的数据类型，而引用在创建时需要指定数据类型。
- VARIANT 变量在运行过程中可以定义不同的数据类型，引用则始终指向同一数据类型。
- 引用可以直接读写被引用的变量，而 VARIANT 变量需要使用特殊指令（如 VariantGet 和 VariantPut）进行读写。
- 引用只能指向位于优化存储区中的数据，而 VARIANT 变量可以指向更广泛的数据类型。

VARIANT 数据类型的变量与一个指向任意数据类型的其它变量类似。因此，在程序创建时，无需定义 VARIANT 变量所指向的数据类型。即，在运行过程中无需定义该数据类型。在不同的程序循环中，一个 VARIANT 变量甚至可以定义不同的数据类型。数据类型 VARIANT 适用于创建通用程序和间接寻址。但如需要在程序代码中对 VARIANT 变量进行进一步处理，则需使用特定指令确定当前的数据类型。不能直接读写 VARIANT 变量。而必须使用 VariantGet 和 VariantPut 等特殊指令进行读写。

引用可在函数或函数块的块接口中声明。为此，可使用以下声明区域：
- FC：Input, Output, Temp, Return
- FB：Temp
- OB：Temp

要进行引用声明，可使用关键字 “REF_TO” 并指定被引用变量所需的数据类型。但是，无需指定该引用指向的特定变量。

引用可指向以下元素：
- 位字符串
- 整数
- 浮点数
- 字符串
- IEC 定时器
- IEC 计数器
- PLC 数据类型 (UDT)
- 系统数据类型 (SDT)
- ARRAY
- 工艺对象
- 数据块

在创建一个引用变量时，系统将使用值 NULL 对其进行初始化。即，引用虽然存在，但未指向任何有效的存储器。如果在对 ZERO 引用进行访问，则将输出一个编程错误。

关键字 “REF()”用于指定先前所声明引用将指向的变量。即，通过参数指定待引用的变量。该变量的数据类型必须与所声明引用的数据类型完全匹配。

以下规则适用于“引用”：
- 引用所指向的数据需位于一个优化存储空间内。
- 该引用只能指向全局 DB 或静态变量中的数据。
- 该引用不能引用以下数据：
  - 临时本地数据
  - PLC 变量表中的全局变量
  - 块参数
  - 常量
  - 设置写保护的变量
- 以下规则适用于引用数组：
  - 数组限值、引用维数以及被引用的变量数必须相同。
  - 不能创建对具有动态限制的数组的引用 (Array[*])。
  - 必须使用以下语句创建基于 PLC 数据类型的 ARRAY DB 引用：
    REF("my_ArrayDB_UDT"."THIS")
    REF("my_ArrayDB_UDT"."THIS"[i])
- 无法使用 REF() 引用工艺对象。

引用的规则：
- 引用所指向的数据需位于一个优化存储空间内。
- 该引用只能指向全局 DB 或静态变量中的数据。
- 该引用不能引用以下数据：
  - 临时本地数据
  - PLC 变量表中的全局变量
  - 块参数
  - 常量
  - 设置写保护的变量
- 以下规则适用于引用数组：
  - 数组限值、引用维数以及被引用的变量数必须相同。
  - 不能创建对具有动态限制的数组的引用 (Array[*])。
  - 必须使用以下语句创建基于 PLC 数据类型的 ARRAY DB 引用：
    REF("my_ArrayDB_UDT"."THIS")
    REF("my_ArrayDB_UDT"."THIS"[i])
- 无法使用 REF() 引用工艺对象。

块的接口包含一个声明为引用的“myRefInt”参数，以及已初始化为某个值的一些静态参数。
引用可以使用“REF()”指令指定，例如将“myRefInt”指定为指向“#a”。
在SCL的计算中可以使用引用指向的变量，例如“#a”。
接口可以包含引用声明，如“myReferenceSpeedAxis”和“myReferencePositioningAxis”。
可以写入和读取引用声明的工艺对象的元素。
引用可作为赋值或比较指令的输入/输出参数。
引用之间可以进行赋值，但数据类型必须相同。
可以将引用赋值给VARIANT，但VARIANT必须声明为临时变量(Temp)。

以下规则适用于工艺对象引用：
- 两个相同类型的工艺对象可以相互分配。
- 派生类型可以分配给其基本类型。
- 基本类型不能分配给其派生类型。
- 不支持指针分配，例如VARIANT。

比较指令支持引用操作，可以通过与NULL比较来确定变量是否已指定给一个引用。

示例说明了SCL赋值和比较指令中引用的使用方式。

尝试赋值可以使用“?=”，例如尝试将VARIANT分配给一个引用。

赋值尝试可以用于检查运行时变量数据类型是否正确。

如果赋值尝试成功，目标变量包含一个有效引用，否则为NULL。

可以使用ENO检查赋值尝试是否成功。

以下规则适用于VARIANT的赋值尝试：
- VARIANT需指向一个优化存储区中的地址。
- VARIANT不得指向临时存储区中的地址。
- VARIANT指定给ARRAY引用时，必须指向一个与引用完全相同的ARRAY。
- VARIANT不能指定给一个工艺对象的引用。
- 在SCL中，赋值尝试无法用于多重赋值运算。

尝试赋值一个引用
- 可进行以下赋值尝试：
  - 尝试将 VARIANT 分配给一个引用
  - 尝试将 DB_ANY 分配给一个工艺对象的引用
- 引用变量的数据类型在声明时确定，而 VARIANT 变量的数据类型则在运行时确定。引用变量不支持隐式数据类型转换。因此，可使用赋值尝试，对这两种数据类型进行相互赋值。使用赋值尝试时，运行过程中将检查所赋值变量的数据类型是否正确。此时，将执行赋值。如果该指令执行成功，则目标变量中包含一个有效的引用，否则为 NULL。
- 以下规则适用于 VARIANT 的赋值尝试。在运行过程中，如果 VARIANT 变量不符合以下规则，则返回值 “NULL”：
  - VARIANT 需指向一个优化存储区中的地址。
  - VARIANT 不得指向临时存储区中的地址。
  - 如需将 VARIANT 指定给一个 ARRAY 引用，则需遵循以下规则：
    - VARIANT 变量必须指向一个限值与所声明的引用完全相同的 ARRAY。指向 ARRAY [0..9] 的 VARIANT 变量与变量 REF_TO ARRAY[1..10] 不匹配。
    - 此外，S7-1500 系列 CPU 固件版本 V2.5 中，还应编译一次用于生成 VARIANT 变量值的块。
  - VARIANT 不能指定给一个工艺对象的引用。
  - 在 SCL 中，赋值尝试无法用于多重赋值运算 (a := b := c;) 中。

尝试将 DB_ANY 分配给一个工艺对象的引用
- 工艺对象的引用通常指向一个特定的工艺目标，如 REF_TO TO_SpeedAxis。在运行过程中，如果使用类型为 DB_ANY 的变量分配一个工艺对象，则需检查该工艺对象是否与所声明的引用相匹配。为此，可使用赋值尝试。使用赋值尝试时，运行过程中将检查该工艺对象是否具有所声明的类型。此时，将执行赋值。如果执行成功，则目标变量中包含一个有效的引用，否则为 NULL。
- 尝试将 DB_ANY 分配给一个工艺对象的引用时，遵循以下规则：
  - DB_ANY 必须指向优化存储区中的工艺对象。
  - 两个相同类型的工艺对象可以相互分配。
  - 派生类型可以分配给其基本类型。
  - 基本类型不能分配给其派生类型。

将引用作为块参数进行传递
- 在函数或函数块调用时，引用也可作为块参数进行传递。
- 将引用作为块参数进行传递时应遵循以下规则：
  - “REF()” 仅能作为函数输入参数 (Input) 中的实参进行传递。
  - “REF()” 不能作为实参传递到数据类型为 “VARIANT” 的块参数中。
  - 所传递变量的数据类型必须与所声明的引用数据类型完全匹配。系统不会进行数据类型转换。
  - 派生工艺对象的引用可以传递给基本类型的引用。
  - 基本类型的引用不能传递给派生工艺对象的引用。

• 从 FB 传递到被调用的 FC：
  - 声明输入参数 "refStationData" 在 "FC StationData" 中。
  - 在调用期间，"FB LineData" 传递 "REF('ReceiveData1')" 作为实际参数。

• 从 FC 返回到调用 FB：
  - 在两个块的接口中声明具有相同数据类型的引用（例如： "refProductionData"）。
  - 在块调用期间，两个引用相互赋值。
  - 在调用的 "FC StationData" 中初始化该引用，并通过输出参数将其写入调用 FB 的临时数据。

示例程序中的块：
- PLC 数据类型 "typeStationData" 包含站的数据。
- DB "ReceiveData" 用于 CPU 之间的通信。
- "FB LineData" 对生产线进行完整分析，并调用 "FC StationData"。
- "FC StationData" 检查接收的新数据来自哪个站，并复制到全局 DB "Station"。
- 全局 DB "Station" 包含五个站的站信息，存储在 "typeStationData" 类型的 ARRAY 中。

以下是指令和规则的提取：

- 使用 "REF" 来传递引用。
- 使用 "TypeOf" 来确定调用时可用的数据类型。
- 使用 "VariantGet" 和 "VariantPut" 来处理 VARIANT 数据类型的变量。
- 使用引用参数来避免复制结构化变量，提高程序运行效率和减少内存要求。
- "AssignmentAttempt" 用于初始化匹配引用。

VARIANT 数据类型的参数是一个指针或引用，可指向各种不同数据类型的变量。VARIANT 指针无法指向实例，因此不能指向多重实例或多重实例的 ARRAY。VARIANT 指针可以是基本数据类型（例如，INT 或 REAL）的对象。还可以是 STRING、DTL、STRUCT 类型的 ARRAY、UDT、UDT 类型的 ARRAY。VARIANT 指针可以识别结构，并指向各个结构元素。VARIANT 数据类型的操作数不占用背景数据块或工作存储器中的空间。但是，将占用 CPU 上的存储空间。

VARIANT 类型的变量不是一个对象，而是对另一个对象的引用。在函数的块接口中的 VAR_IN、VAR_IN_OUT 和 VAR_TEMP 部分中，VARIANT 类型的单个元素只能声明为形参。因此，不能在数据块或函数块的块接口静态部分中声明，例如，因为各元素的大小未知。所引用对象的大小可以更改。

使用 VARIANT 数据类型时，可为各种数据类型创建通用的标准函数块 (FB) 或函数 (FC)。为此，可使用所有编程语言中的各种指令。在程序创建过程中，可指定该块可处理数据类型。在此，可使用 VARIANT 数据类型对各种变量进行互连。之后，再根据这些变量在块中的数据类型进行响应。调用某个块时，可以将该块的参数连接到任何数据类型的变量。调用某个块时，除了传递变量的指针外，还会传递变量的类型信息。块代码随后可以根据运行期间传递的变量类型来执行。

VARIANT 指针的属性：
- 长度（字节）
- 表示法
  - 符号 操作数 "TagResult"
  - 数据块名称.操作数名称.元素 "Data_TIA_Portal".StructVariable.FirstComponent
  - 绝对 操作数 %MW10
  - 数据块编号.操作数 类型长度 P#DB10.DBX10.0 INT 12
  - NULL 指针 NULL

VARIANT 类型的单个元素只能声明为形参。不能在数据块或函数块的块接口静态部分中声明。

使用 VARIANT 数据类型时，可为各种数据类型创建通用的标准函数块 (FB) 或函数 (FC)。在程序创建过程中，可指定该块可处理数据类型。在此，可使用 VARIANT 数据类型对各种变量进行互连。之后，再根据这些变量在块中的数据类型进行响应。调用某个块时，可以将该块的参数连接到任何数据类型的变量。调用某个块时，除了传递变量的指针外，还会传递变量的类型信息。

VARIANT 指针的属性：
- 长度（字节）
- 表示法
  - 符号操作数 "TagResult"
  - 数据块名称.操作数名称.元素 "Data_TIA_Portal".StructVariable.FirstComponent
  - 绝对操作数 %MW10
  - 数据块编号.操作数类型长度 P#DB10.DBX10.0 INT 12
  - NULL指针 NULL

如果通过 P# 使用绝对寻址，则允许使用以下数据类型：
- BOOL
- BYTE
- CHAR
- WORD
- INT
- DWORD
- DINT
- REAL
- TIME
- S5TIME
- DATE
- TOD
- DT

VARIANT 指令：
- 比较器运算
  - EQ_Type
  - NE_Type
  - EQ_ElemType
  - NE_ElemType
  - IS_NULL
  - NOT_NULL
  - IS_ARRAY
  - TypeOf
  - TypeOfElements
- 移动操作
  - MOVE_BLK_VARIANT
  - VariantGet
  - VariantPut
  - CountOfElements
- 转换操作
  - VARIANT_TO_DB_ANY
  - DB_ANY_TO_VARIANT

MOVE、MOVE_BLK 和 MOVE_BLK_VARIANT 之间的区别：
- 可使用“MOVE”指令来复制完整的结构。
- 可使用“MOVE_BLK”指令来移动具有已知数据类型的 ARRAY 的部分。
- 仅在想要移动其数据类型仅在程序运行时期间已知的 ARRAY 的部分时，才需要使用 MOVE_BLK_VARIANT 指令。

基本指令
- 移动操作
  - MOVE_BLK_VARIANT：块移动
  - VariantGet：读取 VARIANT 变量值
  - VariantPut：写入 VARIANT 变量值
  - CountOfElements：获取 ARRAY 元素个数
- 转换操作
  - VARIANT_TO_DB_ANY：将 VARIANT 转换为 DB_ANY
  - DB_ANY_TO_VARIANT：将 DB_ANY 转换为 VARIANT

对 VARIANT 指向的变量的数据类型求值
- 函数 指令 说明
  - 确定数据类型
    - TypeOf()：检查 VARIANT 变量的数据类型
    - TypeOfElements()：扫描 VARIANT 变量 ARRAY 元素的数据类型
  - 比较数据类型
    - EQ_Type：比较数据类型与变量数据类型是否“相等”
    - NE_Type：比较数据类型与变量数据类型是否“不相等”
    - EQ_ElemType：比较 ARRAY 元素数据类型与变量数据类型是否“相等”
    - NE_ElemType：比较 ARRAY 元素数据类型与变量数据类型是否“不相等”
  - 对 ARRAY 元素求值
    - IS_ARRAY：检查 ARRAY
    - CountOfElements：获取 ARRAY 元素个数

将数据分配给 VARIANT 变量
- 指令 说明 示例 结果
  - VariantPut：写入 VARIANT 变量值
    - UDT_1 UDT_1 已执行该指令。
    - REAL REAL
    - DINT DWORD 将不执行该指令，因为数据类型不同。

处理动态 ARRAY 结构
- 对 ARRAY 元素求值
  - TypeOfElements()：扫描 VARIANT 变量 ARRAY 元素的数据类型
  - IS_ARRAY：检查 ARRAY
  - CountOfElements：获取 ARRAY 元素个数
  - MOVE_BLK_VARIANT：块移动

初始化 VARIANT
- 通过在块调用时为 VARIANT 块参数指定一个特定变量，对 VARIANT 数据类型进行初始化。

通过在块调用时为 VARIANT 块参数指定一个特定变量，对 VARIANT 数据类型进行初始化。这将形成对所传递变量地址的引用。为此，需在块接口中创建一个 VARIANT 数据类型的块参数。

系统不支持将变量直接传递到 VARIANT 变量中。例如， myVARIANT := #Variable。

VARIANT 作为形参
如果将 VARIANT 声明为一个形参，则未写保护的数据将作为实参进行传递。

传递各种数据类型
在以下示例中，将显示多次调用通用的标准函数时如何使用不同变量对 VARIANT 块参数进行初始化：

读出并检查数据类型
系统目前支持各种不同的比较指令，可读取变量或元素的数据类型，并将其与其他变量或元素的数据类型进行比较。

仅当 ARRAY 元素的数据类型相同时，才执行 MOVE_BLK_VARIANT 指令。

//以下是提取的语法规则：
- 使用 IF 语句检查 ARRAY 类型和元素类型是否匹配。
- 使用 MOVE_BLK_VARIANT 指令进行数组元素的复制。
- #Error 用于存储错误信息。
- #FC_PartialArrayCopy 用于返回函数调用的结果。

VARIANT 数据类型的相关规则：
- VARIANT 数据类型的参数是一个指针或引用，可指向各种不同数据类型的变量。
- VARIANT 指针无法指向实例，因此不能指向多重实例或多重实例的 ARRAY。
- VARIANT 指针可以是基本数据类型（如INT或REAL）的对象，也可以是STRING、DTL、STRUCT类型的ARRAY、UDT、UDT类型的ARRAY。
- VARIANT 指针可以识别结构，并指向各个结构元素。
- VARIANT 数据类型的操作数不占用背景数据块或工作存储器中的空间，但会占用CPU上的存储空间。

POINTER 类型相关规则：
- POINTER 类型的参数是一个可指向特定变量的指针，它在存储器中占用6个字节（48位）。
- POINTER 类型可以声明以下四种类型的指针：内部区域指针、跨区域指针、DB指针、零指针。
- POINTER 类型的声明格式包括符号、绝对、前缀P#等。
- 使用前缀P#时，只能指向“标准”访问模式的存储区。
- 在STL编程语言中使用前缀P#时，有不同的注意事项，例如在函数(FC)和函数块(FB)中的使用限制。

1. VARIANT 指针属性：
   - 长度（字节）
   - 表示法：符号操作数、数据块名称.操作数名称.元素、绝对操作数、数据块编号.操作数类型长度、NULL指针

2. POINTER 类型存储区十六进制代码：
   - B#16#80: CPU S7-300/400的外围设备
   - 16#1: CPU S7-1500的外围输入
   - 16#2: CPU S7-1500的外围输出
   - B#16#81: I 输入存储区
   - B#16#82: Q 输出存储区
   - B#16#83: M 位存储的存储区
   - B#16#84: DBX 数据块
   - B#16#85: DIX 背景数据块
   - B#16#86: L 本地数据

3. POINTER 类型声明格式：
   - P#ByteRepresentation
   - 示例：P#OperandAreaByte.Bit、P#Data_block.Data_operand、P#零值

使用前缀P#时，只能指向“标准”访问模式的存储区。

块类型 “优化”访问模式 “标准”访问模式
函数 (FC) 在程序代码中，不能使用带前缀P#的变量。在程序代码中，可以使用以下带前缀P#的变量。
- 在块接口的InOut区域中声明变量的结构变量。
- 声明基本数据类型的变量不能使用前缀P#。
函数块 (FB) 在程序代码中，不能使用带前缀P#的变量。在程序代码中，可以使用以下带前缀P#的变量。
- 在块接口的Static、Input和Output区域声明的变量。
- 在块接口的InOut区域中声明的PLC数据类型(UDT)变量。

POINTER参数类型的存储区的十六进制代码：
- B#16#80 P CPU S7-300/400的外围设备
- B#16#1 P CPU S7-1500的外围输入
- B#16#2 P CPU S7-1500的外围输出
- B#16#81 I 输入存储区
- B#16#82 Q 输出存储区
- B#16#83 M 位存储的存储区
- B#16#84 DBX 数据块
- B#16#85 DIX 背景数据块
- B#16#86 L 本地数据
- B#16#87 V 前一个本地数据（调用模块的本地数据）
- B#16#C0等 V 前一个本地数据（上级调用层级中调用模块的本地数据）

ANY类型的参数指向数据区的起始位置，并指定其长度。ANY指针使用存储器中的10个字节。
ANY指针不能指向结构，只能分配给局部变量。
ANY指针的格式：
- 符号P#DataBlock.MemoryArea DataAddress Type Number
- 绝对P#MemoryArea DataAddress Type Number
- P#零值 - 零值

ANY指针的数据类型编码：
- B#16#00 NIL Null指针
- B#16#01 BOOL 位
- B#16#02 BYTE 字节，8位
- B#16#03 CHAR 8位字符
- B#16#04 WORD 16位字
- B#16#05 INT 16位整数
- B#16#06 DWORD 32位字
- B#16#07 DINT 32位整数
- B#16#08 REAL 32位浮点数
- B#16#0B TIME 持续时间
- B#16#0C S5TIME 持续时间
- B#16#09 DATE 日期
- B#16#0A TOD 日期和时间
- B#16#0E DT 日期和时间
- B#16#13 STRING 字符串
- B#16#17 BLOCK_FB 函数块
- B#16#18 BLOCK_FC 函数
- B#16#19 BLOCK_DB 数据块
- B#16#1A BLOCK_SDB 系统数据块
- B#16#1C COUNTER 计数器
- B#16#1D TIMER 定时器

ANY指针的存储区编码：
- B#16#80 P I/O
- B#16#81 I 输入存储区
- B#16#82 Q 输出存储区
- B#16#83 M 位存储的存储区
- B#16#84 DBX 数据块
- B#16#85 DIX 背景数据块
- B#16#86 L 本地数据
- B#16#87 V 前一个本地数据

十六进制代码 数据类型 说明
B#16#07 DINT 32位整数
B#16#08 REAL 32位浮点数
B#16#0B TIME 持续时间
B#16#0C S5TIME 持续时间
B#16#09 DATE 日期
B#16#0A TOD 日期和时间
B#16#0E DT 日期和时间
B#16#13 STRING 字符串
B#16#171) BLOCK_FB 函数块
B#16#181) BLOCK_FC 函数
B#16#191) BLOCK_DB 数据块
B#16#1A1) BLOCK_SDB 系统数据块
B#16#1C1) COUNTER 计数器
B#16#1D1) TIMER 定时器

参数类型 长度（位） 说明
TIMER 16 可用于指定在被调用代码块中所使用的定时器。
COUNTER 16 可用于指定在被调用代码块中使用的计数器。
BLOCK_FC 16 可用于指定在被调用代码块中用作输入的块。
BLOCK_DB 16
BLOCK_SDB 16
